geo $allowed_ip {
    default 0;
    # 10.0.0.1 1; 
    # 注意！
    # コンテナ内で動いているため、オリジナルのIPアドレスではなく、
    # Dockerの内部ネットワークのデフォルトゲートウェイのIPアドレスが設定される。
    # 外部のクライアントのオリジナルなIPが必要なら、
    # コンテナネットワークをホストモードにする？（）などの対応が必要
}

server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    root /usr/share/nginx/html;
    index index.html;

    error_page 404 /file/404.html;
    error_page 503 @maintenance;

    set $maintenance_mode 0;
    if (-f $document_root/file/maintenance.flag) {
        set $maintenance_mode 1;
    }
    if ($allowed_ip = 1) {
        set $maintenance_mode 0;
    }

    location / {
        if ($maintenance_mode = 1) {
            return 503;
        }
        try_files $uri $uri/ =404;
    }

    location /file/ {
        internal;
    }

    location = /test {
        add_header Content-Type text/plain;
        return 200 'this is a test';
    }

    location /minimal_sns_api/v1/ {
        proxy_pass http://minimal_sns_app:1323;
        proxy_intercept_errors on;
        error_page 500 /error.html;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
        # オリジナルのクライアント及びプロキシのIPアドレスが、カンマ区切りでX-Forwarded-Forヘッダに設定される。
        # ただし、中間のプロキシがX-Forwarded-Forヘッダを設定していない場合は、その段階で、それまでの情報が隠蔽されてしまう。
        
        proxy_set_header X-Real-IP $remote_addr; 
        # 直近のリバースプロキシのIPアドレスだけをX-Real-IPヘッダに設定する

        # 上記の２つはアプリケーションの要件によって使い分けるのが一般的だが、今回は課題要件から用途が明白でないので両方を設定しておく
    }

    location /img/ {
        if ($maintenance_mode = 1) {
            return 503;
        }
        expires 24h; # HTTP1.0との互換性のため、Expiresヘッダも設定する
        
        add_header Cache-Control "public, max-age=86400";
        # HTTP1.1のキャッシュコントロールヘッダでより柔軟にキャッシュの設定ができる
        # public: クライアント固有のものではないパブリックなもの。なのでプロキシもキャッシュを保持できる
        # max-age: キャッシュの有効期限を秒単位で指定する
        
        try_files $uri =404;
    }


    location @maintenance {
        rewrite ^ /file/maintenance.html break;
    }
}